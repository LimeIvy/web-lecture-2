# ポストの投稿機能

新しい投稿を作成する機能の実装方法を説明します。

## APIの作成

### 1. バックエンドAPIエンドポイントの追加

バックエンドの `src/routes/posts.ts` に、POSTエンドポイントを追加します。

```typescript:backend/src/routes/posts.ts
import { Hono } from "hono";
import db from "../db/initial";
import type { CreatePost } from "../types";

const posts = new Hono()
  // 投稿一覧取得
  .get("/", (c) => {
    // ... 既存のコード ...
  })
  // 投稿作成
  .post("/", async (c) => {
    try {
      const body = await c.req.json<CreatePost>();
      
      // バリデーション
      if (!body.content || !body.content.trim()) {
        return c.json({ error: "投稿内容を入力してください" }, 400);
      }
      
      if (!body.userId) {
        return c.json({ error: "ユーザーIDが必要です" }, 400);
      }
      
      const insertPost = db.prepare(
        "INSERT INTO posts (content, user_id, created_at) VALUES (?, ?, ?)"
      );
      
      const createdAt = new Date().toISOString();
      const result = insertPost.run(body.content.trim(), body.userId, createdAt);
      
      // idを取得
      const postId = result.lastInsertRowid;
      
      // 作成された投稿をユーザー情報と一緒に取得
      const newPost = db.prepare(`
        SELECT 
          posts.id,
          posts.content,
          posts.created_at,
          posts.user_id,
          users.name,
          users.icon
        FROM posts 
        LEFT JOIN users ON posts.user_id = users.id 
        WHERE posts.id = ?
      `).get(postId) as {
        id: number;
        content: string;
        created_at: string;
        user_id: string;
        name: string;
        icon: string | null;
      };
      
      // フロントエンド用の形式に変換
      return c.json({
        id: newPost.id,
        content: newPost.content,
        created_at: newPost.created_at,
        user: {
          id: newPost.user_id,
          name: newPost.name || "",
          icon: newPost.icon || null,
        }
      }, 201);
    } catch (error) {
      console.error("Error creating post:", error);
      return c.json({ error: "投稿の作成に失敗しました" }, 500);
    }
  });

export default posts;
```

このエンドポイントは `POST http://localhost:8080/posts` でアクセスできます。

## フロントエンドと接続

### 1. PostFormコンポーネントの更新

`src/components/PostForm.tsx` を更新して、APIを呼び出すようにします。

```typescript:frontend/src/components/PostForm.tsx
import { useState } from "react";
import { mockCurrentUser } from "../mocks/user";
import type { PostType } from "../types/post";

type PostFormProps = {
  onPostCreated?: (newPost: PostType) => void;
};

export const PostForm = ({ onPostCreated }: PostFormProps) => {
  const [content, setContent] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { icon: userIcon, id: userId } = mockCurrentUser;

  const handleSubmit = async () => {
    const trimmedContent = content.trim();
    if (!trimmedContent) {
      alert("投稿内容を入力してください。");
      return;
    }

    setIsSubmitting(true);

    try {
      const response = await fetch("http://localhost:8080/posts", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          content: trimmedContent,
          userId: userId,
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || "投稿に失敗しました");
      }

      const newPost = await response.json(); // APIから返ってきた新しい投稿データ
      setContent("");
      
      // 新しい投稿データを親コンポーネントに渡す
      if (onPostCreated) {
        onPostCreated(newPost);
      }
      
      alert("投稿しました！");
    } catch (error) {
      console.error("Error creating post:", error);
      alert(error instanceof Error ? error.message : "投稿に失敗しました");
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="border-b border-gray-800 p-4">
      <div className="flex">
        <div className="mr-4 flex-shrink-0">
          <div className="h-10 w-10 overflow-hidden rounded-full bg-gray-700">
            <img
              src={userIcon || ""}
              alt="user icon"
              className="h-full w-full object-cover"
              onError={(e) => {
                e.currentTarget.style.display = "none";
              }}
            />
          </div>
        </div>

        <div className="mt-1.5 flex-1">
          <textarea
            placeholder="いまどうしてる？"
            className="w-full resize-none bg-transparent text-xl text-white outline-none"
            rows={2}
            value={content}
            onChange={(e) => setContent(e.target.value)}
          />
          <div className="mt-2 flex justify-end">
            <button
              className="cursor-pointer rounded-full bg-white px-4 py-1.5 font-bold text-black transition-colors enabled:hover:bg-gray-200 disabled:opacity-50 disabled:cursor-default"
              onClick={handleSubmit}
              disabled={!content.trim() || isSubmitting}
            >
              {isSubmitting ? "投稿中..." : "ポストする"}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};
```

### 2. Appコンポーネントの更新

投稿後に一覧を更新するため、APIから返ってきた新しい投稿を直接配列の先頭に追加します。再取得が不要で効率的です。

```typescript:frontend/src/App.tsx
// ... 既存のコード ...

function App() {
  const [posts, setPosts] = useState<PostType[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchPosts = async () => {
      try {
        setLoading(true);
        const response = await fetch("http://localhost:8080/posts");
        if (!response.ok) {
          throw new Error("Failed to fetch posts");
        }
        const data = await response.json();
        setPosts(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Unknown error");
      } finally {
        setLoading(false);
      }
    };

    fetchPosts();
  }, []);

  const handlePostCreated = (newPost: PostType) => {
    setPosts((prevPosts) => [newPost, ...prevPosts]);
  };

  return (
    <div className="flex min-h-screen justify-center bg-black">
      {/* ... 既存のコード ... */}
      <PostForm onPostCreated={handlePostCreated} />
      {/* ... 既存のコード ... */}
    </div>
  );
}
```

### 3. PostFormコンポーネントの更新

APIから返ってきた新しい投稿データを親コンポーネントに渡すように更新します。

```typescript:frontend/src/components/PostForm.tsx
type PostFormProps = {
  onPostCreated?: (newPost: PostType) => void; // 新しい投稿データを受け取る
};

export const PostForm = ({ onPostCreated }: PostFormProps) => {
  // ... 既存のコード ...

  const handleSubmit = async () => {
    const trimmedContent = content.trim();
    if (!trimmedContent) {
      alert("投稿内容を入力してください。");
      return;
    }

    setIsSubmitting(true);

    try {
      const response = await fetch("http://localhost:8080/posts", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          content: trimmedContent,
          userId: userId,
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || "投稿に失敗しました");
      }

      const newPost = await response.json(); // APIから返ってきた新しい投稿データ
      setContent("");
      
      // 新しい投稿データを親コンポーネントに渡す
      if (onPostCreated) {
        onPostCreated(newPost);
      }
      
      alert("投稿しました！");
    } catch (error) {
      console.error("Error creating post:", error);
      alert(error instanceof Error ? error.message : "投稿に失敗しました");
    } finally {
      setIsSubmitting(false);
    }
  };

  // ... 既存のコード ...
};
```

## 修正後のコード一覧

このセクションでは、マークダウンファイルを通じて変更されたすべてのコードを記載します。

### 1. バックエンドAPI (`backend/src/routes/posts.ts`)

POSTエンドポイントを追加：

```typescript
import { Hono } from "hono";
import db from "../db/initial";
import type { CreatePost } from "../types";

const posts = new Hono()
  // 投稿一覧取得(ユーザ情報付き)
  .get("/", (c) => {
    const posts = db.prepare(`
      SELECT 
        posts.id,
        posts.content,
        posts.created_at,
        posts.user_id,
        users.name,
        users.icon
      FROM posts 
      LEFT JOIN users ON posts.user_id = users.id 
      ORDER BY posts.created_at DESC
    `).all();

    return c.json(posts.map((post: any) => ({
      id: post.id,
      content: post.content,
      created_at: post.created_at,
      user: {
        id: post.user_id,
        name: post.name || "",
        icon: post.icon || null,
      }
    })));
  })
  // 投稿作成
  .post("/", async (c) => {
    try {
      const body = await c.req.json<CreatePost>();
      
      if (!body.content || !body.content.trim()) {
        return c.json({ error: "投稿内容を入力してください" }, 400);
      }
      
      if (!body.userId) {
        return c.json({ error: "ユーザーIDが必要です" }, 400);
      }
      
      const insertPost = db.prepare(
        "INSERT INTO posts (content, user_id, created_at) VALUES (?, ?, ?)"
      );
      
      const createdAt = new Date().toISOString();
      const result = insertPost.run(body.content.trim(), body.userId, createdAt);
      
      // idを取得
      const postId = result.lastInsertRowid;
      
      const newPost = db.prepare(`
        SELECT 
          posts.id,
          posts.content,
          posts.created_at,
          posts.user_id,
          users.name,
          users.icon
        FROM posts 
        LEFT JOIN users ON posts.user_id = users.id 
        WHERE posts.id = ?
      `).get(postId) as {
        id: number;
        content: string;
        created_at: string;
        user_id: string;
        name: string;
        icon: string | null;
      };
      
      return c.json({
        id: newPost.id,
        content: newPost.content,
        created_at: newPost.created_at,
        user: {
          id: newPost.user_id,
          name: newPost.name || "",
          icon: newPost.icon || null,
        }
      }, 201);
    } catch (error) {
      console.error("Error creating post:", error);
      return c.json({ error: "投稿の作成に失敗しました" }, 500);
    }
  });

export default posts;
```

### 2. PostFormコンポーネント (`frontend/src/components/PostForm.tsx`)

APIを呼び出すように更新：

```typescript
import { useState } from "react";
import { mockCurrentUser } from "../mocks/user";
import type { PostType } from "../types/post";

type PostFormProps = {
  onPostCreated?: (newPost: PostType) => void;
};

export const PostForm = ({ onPostCreated }: PostFormProps) => {
  const [content, setContent] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { icon: userIcon, id: userId } = mockCurrentUser;

  const handleSubmit = async () => {
    const trimmedContent = content.trim();
    if (!trimmedContent) {
      alert("投稿内容を入力してください。");
      return;
    }

    setIsSubmitting(true);

    try {
      const response = await fetch("http://localhost:8080/posts", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          content: trimmedContent,
          userId: userId,
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || "投稿に失敗しました");
      }

      const newPost = await response.json();
      setContent("");
      
      if (onPostCreated) {
        onPostCreated(newPost);
      }
      
      alert("投稿しました！");
    } catch (error) {
      console.error("Error creating post:", error);
      alert(error instanceof Error ? error.message : "投稿に失敗しました");
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="border-b border-gray-800 p-4">
      <div className="flex">
        <div className="mr-4 flex-shrink-0">
          <div className="h-10 w-10 overflow-hidden rounded-full bg-gray-700">
            <img
              src={userIcon || ""}
              alt="user icon"
              className="h-full w-full object-cover"
              onError={(e) => {
                e.currentTarget.style.display = "none";
              }}
            />
          </div>
        </div>

        <div className="mt-1.5 flex-1">
          <textarea
            placeholder="いまどうしてる？"
            className="w-full resize-none bg-transparent text-xl text-white outline-none"
            rows={2}
            value={content}
            onChange={(e) => setContent(e.target.value)}
          />
          <div className="mt-2 flex justify-end">
            <button
              className="cursor-pointer rounded-full bg-white px-4 py-1.5 font-bold text-black transition-colors enabled:hover:bg-gray-200 disabled:opacity-50 disabled:cursor-default"
              onClick={handleSubmit}
              disabled={!content.trim() || isSubmitting}
            >
              {isSubmitting ? "投稿中..." : "ポストする"}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};
```

### 3. Appコンポーネント (`frontend/src/App.tsx`)

投稿後に一覧を更新する処理を追加：

```typescript
import { useState, useEffect } from "react";
import { LeftSidebar } from "./components/sidebar/LeftSidebar";
import { RightSidebar } from "./components/sidebar/RightSidebar";
import { Header } from "./components/Header";
import { PostForm } from "./components/PostForm";
import Post from "./components/Post";
import type { PostType } from "./types/post";

function App() {
  const [posts, setPosts] = useState<PostType[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchPosts = async () => {
      try {
        setLoading(true);
        const response = await fetch("http://localhost:8080/posts");
        if (!response.ok) {
          throw new Error("Failed to fetch posts");
        }
        const data = await response.json();
        setPosts(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Unknown error");
      } finally {
        setLoading(false);
      }
    };

    fetchPosts();
  }, []);

  const handlePostCreated = (newPost: PostType) => {
    setPosts((prevPosts) => [newPost, ...prevPosts]);
  };

  return (
    <div className="flex min-h-screen justify-center bg-black">
      {/* コンテンツラッパー */}
      <div className="flex w-full max-w-7xl">
        {/* レフトサイドバー */}
        <div className="w-[68px] flex-shrink-0 lg:w-[275px]">
          <LeftSidebar />
        </div>

        {/* メインコンテンツ */}
        <div className="min-h-screen w-full max-w-[600px] border-x border-gray-800">
          <Header title="おすすめ" />
          {/* 投稿フォーム */}
          <PostForm onPostCreated={handlePostCreated} />
          {/* 投稿一覧 */}
          {loading ? (
            <div className="flex items-center justify-center p-8">
              <div className="text-gray-500">読み込み中...</div>
            </div>
          ) : error ? (
            <div className="flex items-center justify-center p-8">
              <div className="text-red-500">エラー: {error}</div>
            </div>
          ) : (
            <Post posts={posts} />
          )}
        </div>

        {/* ライトサイドバー - 大画面のみ表示 */}
        <div className="hidden w-[350px] flex-shrink-0 lg:block">
          <RightSidebar />
        </div>
      </div>
    </div>
  );
}

export default App;
```
